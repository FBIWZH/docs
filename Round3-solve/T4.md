## $ T4 \ 啊?$

- $10\%$的数据，爆搜

- $40\%$的数据，枚举

- $70\%$的数据，首先你需要知道：

  - `ab=aac=c`即两个任意字符可以变成剩余的字符；

  - 进行合并时，若$res_i=res_j$，则合并结果为空，否则合并结果为另一个字符（结合第一条性质）。我们不难打出以下一段代码：

    ```c++
    inline int change(int a, int b) {//0,1,2,3 分别表示空,X,Y,Z
        if(b < a) swap(a, b);
        if(a == b) return 0;
        else if((a == 0 && b == 1) || (a == 2 && b == 3)) return 1;
        else if((a == 0 && b == 2) || (a == 1 && b == 3)) return 2;
        else return 3;
    }
    ```

    请想象：两个不同的变成第三个，两个一样的变成空。

    那就是异或。直接异或区间字符即可。静态操作可以使用前缀和差分或倍增。

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e5 + 5;
    int pre[N], n, m;
    char ch;
    int main() {
        ios::sync_with_stdio(false);
        cin >> n >> m;
        for(int i = 1; i <= n; i++) {
            cin >> ch;
            pre[i] = pre[i - 1] ^ (ch - 'X' + 1);
        }
        for(int i = 1, op, l, r; i <= m; i++) {
            cin >> op >> l >> r >> ch;
            cout << ((pre[r] ^ pre[l - 1]) == (ch - 'X' + 1) ? "Yes\n" : "No\n");
        }
        return 0;
    }
    ```

- $100\%$的数据，咳咳，我知道你们都在等这个

  使用珂朵莉树或分块或线段树维护

  这里以线段树为例

  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int maxn=5e6;
  int n,m,val[maxn],cov[maxn],num[maxn];//val是值（即x，y或z），cov是把那一堆区间改成另一个字符的标记。
  char s[maxn],c;
  inline int change(int x,int y){//2转1。
      if(x==y)return 0;
      if(x==1&&y==2||x==0&&y==3||x==2&&y==1||x==3&&y==0)return 3;
      if(x==1&&y==3||x==0&&y==2||x==3&&y==1||x==2&&y==0)return 2;
      return 1;
  }
  inline void pushup(int rt){//模板
      val[rt]=change(val[rt<<1],val[rt<<1|1]);
      return ;
  }
  inline void build(int rt,int l,int r){//模板
      cov[rt]=-1;
      if(l==r){val[rt]=num[l];return ;}
      int mid=l+r>>1;
      build(rt<<1,l,mid),build(rt<<1|1,mid+1,r);
      pushup(rt);
      return ;
  }
  inline void pushdown(int rt,int l,int r){
      int mid=l+r>>1;
      if(~cov[rt]){//cov=-1表示没操作
          val[rt<<1]=(mid+1-l)&1?cov[rt]:0;//如果区间是奇数，一定会留下一个数，否则没有数。没有数就是0
          val[rt<<1|1]=(r-mid)&1?cov[rt]:0;//同理
          cov[rt<<1]=cov[rt];//下面模板
          cov[rt<<1|1]=cov[rt];
          cov[rt]=-1;
      }
      return ;
  }
  inline void sett(int rt,int l,int r,int ql,int qr,int v){//模板修改
      if(ql<=l&&r<=qr){val[rt]=(r-l+1)&1?v:0;cov[rt]=v;return ;}
      int mid=l+r>>1;
      pushdown(rt,l,r);
      if(ql<=mid)sett(rt<<1,l,mid,ql,qr,v);
      if(qr>mid)sett(rt<<1|1,mid+1,r,ql,qr,v);
      pushup(rt);
      return ;
  }
  inline int query(int rt,int l,int r,int ql,int qr){//模板询问
      if(ql<=l&&r<=qr)return val[rt];
      int mid=l+r>>1;pushdown(rt,l,r);
      if(ql<=mid&&qr>mid)return change(query(rt<<1,l,mid,ql,qr),query(rt<<1|1,mid+1,r,ql,qr));
      if(ql<=mid)return query(rt<<1,l,mid,ql,qr);
      if(qr>mid)return query(rt<<1|1,mid+1,r,ql,qr);
      return 0;
  }
  int main(){
      scanf("%d%d\n%s",&n,&m,s);
      for(int i=0;i<n;i++)num[i+1]=s[i]-'W';
      build(1,1,n);
      for(int op,x,y,i=1;i<=m;i++){
          scanf("%d%d%d %c",&op,&x,&y,&c);
          if(op==1)sett(1,1,n,x,y,c-'W');
          else if(op==2)printf(query(1,1,n,x,y)==c-'W'?"Yes\n":"No\n");
      }
      return 0;
  }
  ```

  
